// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type AutoscalingGroupInitParameters struct {

	// Unique identifier for the resource
	// +crossplane:generate:reference:type=github.com/ionos-cloud/provider-upjet-ionoscloud/apis/cluster/compute/v1alpha1.Datacenter
	DatacenterID *string `json:"datacenterId,omitempty" tf:"datacenter_id,omitempty"`

	// Reference to a Datacenter in compute to populate datacenterId.
	// +kubebuilder:validation:Optional
	DatacenterIDRef *v1.Reference `json:"datacenterIdRef,omitempty" tf:"-"`

	// Selector for a Datacenter in compute to populate datacenterId.
	// +kubebuilder:validation:Optional
	DatacenterIDSelector *v1.Selector `json:"datacenterIdSelector,omitempty" tf:"-"`

	// The maximum value for the number of replicas on a VM Auto Scaling Group. Must be >= 0 and <= 200. Will be enforced for both automatic and manual changes.
	MaxReplicaCount *float64 `json:"maxReplicaCount,omitempty" tf:"max_replica_count,omitempty"`

	// The minimum value for the number of replicas on a VM Auto Scaling Group. Must be >= 0 and <= 200. Will be enforced for both automatic and manual changes
	MinReplicaCount *float64 `json:"minReplicaCount,omitempty" tf:"min_replica_count,omitempty"`

	// User-defined name for the Autoscaling Group.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Defines the behavior of this VM Auto Scaling Group. A policy consists of triggers and actions, where an action is an automated behavior, and the trigger defines the circumstances under which the action is triggered. Currently, two separate actions are supported, namely scaling inward and outward, triggered by the thresholds defined for a particular metric.
	Policy *PolicyInitParameters `json:"policy,omitempty" tf:"policy,omitempty"`

	ReplicaConfiguration []ReplicaConfigurationInitParameters `json:"replicaConfiguration,omitempty" tf:"replica_configuration,omitempty"`
}

type AutoscalingGroupObservation struct {

	// Unique identifier for the resource
	DatacenterID *string `json:"datacenterId,omitempty" tf:"datacenter_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Location of the data center.
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// The maximum value for the number of replicas on a VM Auto Scaling Group. Must be >= 0 and <= 200. Will be enforced for both automatic and manual changes.
	MaxReplicaCount *float64 `json:"maxReplicaCount,omitempty" tf:"max_replica_count,omitempty"`

	// The minimum value for the number of replicas on a VM Auto Scaling Group. Must be >= 0 and <= 200. Will be enforced for both automatic and manual changes
	MinReplicaCount *float64 `json:"minReplicaCount,omitempty" tf:"min_replica_count,omitempty"`

	// User-defined name for the Autoscaling Group.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Defines the behavior of this VM Auto Scaling Group. A policy consists of triggers and actions, where an action is an automated behavior, and the trigger defines the circumstances under which the action is triggered. Currently, two separate actions are supported, namely scaling inward and outward, triggered by the thresholds defined for a particular metric.
	Policy *PolicyObservation `json:"policy,omitempty" tf:"policy,omitempty"`

	ReplicaConfiguration []ReplicaConfigurationObservation `json:"replicaConfiguration,omitempty" tf:"replica_configuration,omitempty"`
}

type AutoscalingGroupParameters struct {

	// Unique identifier for the resource
	// +crossplane:generate:reference:type=github.com/ionos-cloud/provider-upjet-ionoscloud/apis/cluster/compute/v1alpha1.Datacenter
	// +kubebuilder:validation:Optional
	DatacenterID *string `json:"datacenterId,omitempty" tf:"datacenter_id,omitempty"`

	// Reference to a Datacenter in compute to populate datacenterId.
	// +kubebuilder:validation:Optional
	DatacenterIDRef *v1.Reference `json:"datacenterIdRef,omitempty" tf:"-"`

	// Selector for a Datacenter in compute to populate datacenterId.
	// +kubebuilder:validation:Optional
	DatacenterIDSelector *v1.Selector `json:"datacenterIdSelector,omitempty" tf:"-"`

	// The maximum value for the number of replicas on a VM Auto Scaling Group. Must be >= 0 and <= 200. Will be enforced for both automatic and manual changes.
	// +kubebuilder:validation:Optional
	MaxReplicaCount *float64 `json:"maxReplicaCount,omitempty" tf:"max_replica_count,omitempty"`

	// The minimum value for the number of replicas on a VM Auto Scaling Group. Must be >= 0 and <= 200. Will be enforced for both automatic and manual changes
	// +kubebuilder:validation:Optional
	MinReplicaCount *float64 `json:"minReplicaCount,omitempty" tf:"min_replica_count,omitempty"`

	// User-defined name for the Autoscaling Group.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Defines the behavior of this VM Auto Scaling Group. A policy consists of triggers and actions, where an action is an automated behavior, and the trigger defines the circumstances under which the action is triggered. Currently, two separate actions are supported, namely scaling inward and outward, triggered by the thresholds defined for a particular metric.
	// +kubebuilder:validation:Optional
	Policy *PolicyParameters `json:"policy,omitempty" tf:"policy,omitempty"`

	// +kubebuilder:validation:Optional
	ReplicaConfiguration []ReplicaConfigurationParameters `json:"replicaConfiguration,omitempty" tf:"replica_configuration,omitempty"`
}

type FirewallRuleInitParameters struct {

	// Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.
	IcmpCode *float64 `json:"icmpCode,omitempty" tf:"icmp_code,omitempty"`

	// Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.
	IcmpType *float64 `json:"icmpType,omitempty" tf:"icmp_type,omitempty"`

	// The name of the firewall rule.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
	PortRangeEnd *float64 `json:"portRangeEnd,omitempty" tf:"port_range_end,omitempty"`

	// Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
	PortRangeStart *float64 `json:"portRangeStart,omitempty" tf:"port_range_start,omitempty"`

	// The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.
	SourceIP *string `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`

	// Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.
	SourceMac *string `json:"sourceMac,omitempty" tf:"source_mac,omitempty"`

	// If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.
	TargetIP *string `json:"targetIp,omitempty" tf:"target_ip,omitempty"`

	// The firewall rule type. If not specified, the default value 'INGRESS' is used.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type FirewallRuleObservation struct {

	// Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.
	IcmpCode *float64 `json:"icmpCode,omitempty" tf:"icmp_code,omitempty"`

	// Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.
	IcmpType *float64 `json:"icmpType,omitempty" tf:"icmp_type,omitempty"`

	// The name of the firewall rule.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
	PortRangeEnd *float64 `json:"portRangeEnd,omitempty" tf:"port_range_end,omitempty"`

	// Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
	PortRangeStart *float64 `json:"portRangeStart,omitempty" tf:"port_range_start,omitempty"`

	// The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.
	SourceIP *string `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`

	// Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.
	SourceMac *string `json:"sourceMac,omitempty" tf:"source_mac,omitempty"`

	// If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.
	TargetIP *string `json:"targetIp,omitempty" tf:"target_ip,omitempty"`

	// The firewall rule type. If not specified, the default value 'INGRESS' is used.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type FirewallRuleParameters struct {

	// Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.
	// +kubebuilder:validation:Optional
	IcmpCode *float64 `json:"icmpCode,omitempty" tf:"icmp_code,omitempty"`

	// Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.
	// +kubebuilder:validation:Optional
	IcmpType *float64 `json:"icmpType,omitempty" tf:"icmp_type,omitempty"`

	// The name of the firewall rule.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
	// +kubebuilder:validation:Optional
	PortRangeEnd *float64 `json:"portRangeEnd,omitempty" tf:"port_range_end,omitempty"`

	// Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
	// +kubebuilder:validation:Optional
	PortRangeStart *float64 `json:"portRangeStart,omitempty" tf:"port_range_start,omitempty"`

	// The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.
	// +kubebuilder:validation:Optional
	SourceIP *string `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`

	// Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.
	// +kubebuilder:validation:Optional
	SourceMac *string `json:"sourceMac,omitempty" tf:"source_mac,omitempty"`

	// If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.
	// +kubebuilder:validation:Optional
	TargetIP *string `json:"targetIp,omitempty" tf:"target_ip,omitempty"`

	// The firewall rule type. If not specified, the default value 'INGRESS' is used.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type FlowLogInitParameters struct {

	// Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// The bucket name of an existing IONOS Object Storage bucket. Immutable, forces re-recreation of the nic resource.
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
	Direction *string `json:"direction,omitempty" tf:"direction,omitempty"`

	// The resource name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type FlowLogObservation struct {

	// Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// The bucket name of an existing IONOS Object Storage bucket. Immutable, forces re-recreation of the nic resource.
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
	Direction *string `json:"direction,omitempty" tf:"direction,omitempty"`

	// The resource's unique identifier.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The resource name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type FlowLogParameters struct {

	// Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// The bucket name of an existing IONOS Object Storage bucket. Immutable, forces re-recreation of the nic resource.
	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
	// +kubebuilder:validation:Optional
	Direction *string `json:"direction" tf:"direction,omitempty"`

	// The resource name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type NicInitParameters struct {

	// Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.
	DHCP *bool `json:"dhcp,omitempty" tf:"dhcp,omitempty"`

	// Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.
	FirewallActive *bool `json:"firewallActive,omitempty" tf:"firewall_active,omitempty"`

	// List of all firewall rules for the specified NIC.
	FirewallRule []FirewallRuleInitParameters `json:"firewallRule,omitempty" tf:"firewall_rule,omitempty"`

	// The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.
	FirewallType *string `json:"firewallType,omitempty" tf:"firewall_type,omitempty"`

	// List of all flow logs for the specified NIC.
	FlowLog []FlowLogInitParameters `json:"flowLog,omitempty" tf:"flow_log,omitempty"`

	// Lan ID for this replica Nic.
	// +crossplane:generate:reference:type=github.com/ionos-cloud/provider-upjet-ionoscloud/apis/cluster/compute/v1alpha1.Lan
	Lan *float64 `json:"lan,omitempty" tf:"lan,omitempty"`

	// Reference to a Lan in compute to populate lan.
	// +kubebuilder:validation:Optional
	LanRef *v1.Reference `json:"lanRef,omitempty" tf:"-"`

	// Selector for a Lan in compute to populate lan.
	// +kubebuilder:validation:Optional
	LanSelector *v1.Selector `json:"lanSelector,omitempty" tf:"-"`

	// Name for this replica NIC.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// In order to link VM to ALB, target group must be provided.
	TargetGroup *TargetGroupInitParameters `json:"targetGroup,omitempty" tf:"target_group,omitempty"`
}

type NicObservation struct {

	// Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.
	DHCP *bool `json:"dhcp,omitempty" tf:"dhcp,omitempty"`

	// Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.
	FirewallActive *bool `json:"firewallActive,omitempty" tf:"firewall_active,omitempty"`

	// List of all firewall rules for the specified NIC.
	FirewallRule []FirewallRuleObservation `json:"firewallRule,omitempty" tf:"firewall_rule,omitempty"`

	// The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.
	FirewallType *string `json:"firewallType,omitempty" tf:"firewall_type,omitempty"`

	// List of all flow logs for the specified NIC.
	FlowLog []FlowLogObservation `json:"flowLog,omitempty" tf:"flow_log,omitempty"`

	// Lan ID for this replica Nic.
	Lan *float64 `json:"lan,omitempty" tf:"lan,omitempty"`

	// Name for this replica NIC.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// In order to link VM to ALB, target group must be provided.
	TargetGroup *TargetGroupObservation `json:"targetGroup,omitempty" tf:"target_group,omitempty"`
}

type NicParameters struct {

	// Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.
	// +kubebuilder:validation:Optional
	DHCP *bool `json:"dhcp,omitempty" tf:"dhcp,omitempty"`

	// Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.
	// +kubebuilder:validation:Optional
	FirewallActive *bool `json:"firewallActive,omitempty" tf:"firewall_active,omitempty"`

	// List of all firewall rules for the specified NIC.
	// +kubebuilder:validation:Optional
	FirewallRule []FirewallRuleParameters `json:"firewallRule,omitempty" tf:"firewall_rule,omitempty"`

	// The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.
	// +kubebuilder:validation:Optional
	FirewallType *string `json:"firewallType,omitempty" tf:"firewall_type,omitempty"`

	// List of all flow logs for the specified NIC.
	// +kubebuilder:validation:Optional
	FlowLog []FlowLogParameters `json:"flowLog,omitempty" tf:"flow_log,omitempty"`

	// Lan ID for this replica Nic.
	// +crossplane:generate:reference:type=github.com/ionos-cloud/provider-upjet-ionoscloud/apis/cluster/compute/v1alpha1.Lan
	// +kubebuilder:validation:Optional
	Lan *float64 `json:"lan,omitempty" tf:"lan,omitempty"`

	// Reference to a Lan in compute to populate lan.
	// +kubebuilder:validation:Optional
	LanRef *v1.Reference `json:"lanRef,omitempty" tf:"-"`

	// Selector for a Lan in compute to populate lan.
	// +kubebuilder:validation:Optional
	LanSelector *v1.Selector `json:"lanSelector,omitempty" tf:"-"`

	// Name for this replica NIC.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// In order to link VM to ALB, target group must be provided.
	// +kubebuilder:validation:Optional
	TargetGroup *TargetGroupParameters `json:"targetGroup,omitempty" tf:"target_group,omitempty"`
}

type PolicyInitParameters struct {

	// The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals.
	Metric *string `json:"metric,omitempty" tf:"metric,omitempty"`

	// Specifies the time range for which the samples are to be aggregated. Must be >= 2 minutes.
	Range *string `json:"range,omitempty" tf:"range,omitempty"`

	// Defines the action to be taken when the 'scaleInThreshold' is exceeded. Here, scaling is always about removing VMs associated with this VM Auto Scaling Group. By default, the termination policy is 'OLDEST_SERVER_FIRST' is effective.
	ScaleInAction *ScaleInActionInitParameters `json:"scaleInAction,omitempty" tf:"scale_in_action,omitempty"`

	// The upper threshold for the value of the 'metric'. Used with the 'greater than' (>) operator. A scale-out action is triggered when this value is exceeded, specified by the 'scale_out_action' property. The value must have a lower minimum delta to the 'scale_in_threshold', depending on the metric, to avoid competing for actions simultaneously. If 'properties.policy.unit=TOTAL', a value >= 40 must be chosen.
	ScaleInThreshold *float64 `json:"scaleInThreshold,omitempty" tf:"scale_in_threshold,omitempty"`

	// Defines the action to be performed when the 'scaleOutThreshold' is exceeded. Here, scaling is always about adding new VMs to this VM Auto Scaling Group.
	ScaleOutAction *ScaleOutActionInitParameters `json:"scaleOutAction,omitempty" tf:"scale_out_action,omitempty"`

	// The upper threshold for the value of the 'metric'. Used with the 'greater than' (>) operator. A scale-out action is triggered when this value is exceeded, specified by the 'scaleOutAction' property. The value must have a lower minimum delta to the 'scaleInThreshold', depending on the metric, to avoid competing for actions simultaneously. If 'properties.policy.unit=TOTAL', a value >= 40 must be chosen.
	ScaleOutThreshold *float64 `json:"scaleOutThreshold,omitempty" tf:"scale_out_threshold,omitempty"`

	// Units of the applied Metric. Possible values are: PER_HOUR, PER_MINUTE, PER_SECOND, TOTAL.
	Unit *string `json:"unit,omitempty" tf:"unit,omitempty"`
}

type PolicyObservation struct {

	// The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals.
	Metric *string `json:"metric,omitempty" tf:"metric,omitempty"`

	// Specifies the time range for which the samples are to be aggregated. Must be >= 2 minutes.
	Range *string `json:"range,omitempty" tf:"range,omitempty"`

	// Defines the action to be taken when the 'scaleInThreshold' is exceeded. Here, scaling is always about removing VMs associated with this VM Auto Scaling Group. By default, the termination policy is 'OLDEST_SERVER_FIRST' is effective.
	ScaleInAction *ScaleInActionObservation `json:"scaleInAction,omitempty" tf:"scale_in_action,omitempty"`

	// The upper threshold for the value of the 'metric'. Used with the 'greater than' (>) operator. A scale-out action is triggered when this value is exceeded, specified by the 'scale_out_action' property. The value must have a lower minimum delta to the 'scale_in_threshold', depending on the metric, to avoid competing for actions simultaneously. If 'properties.policy.unit=TOTAL', a value >= 40 must be chosen.
	ScaleInThreshold *float64 `json:"scaleInThreshold,omitempty" tf:"scale_in_threshold,omitempty"`

	// Defines the action to be performed when the 'scaleOutThreshold' is exceeded. Here, scaling is always about adding new VMs to this VM Auto Scaling Group.
	ScaleOutAction *ScaleOutActionObservation `json:"scaleOutAction,omitempty" tf:"scale_out_action,omitempty"`

	// The upper threshold for the value of the 'metric'. Used with the 'greater than' (>) operator. A scale-out action is triggered when this value is exceeded, specified by the 'scaleOutAction' property. The value must have a lower minimum delta to the 'scaleInThreshold', depending on the metric, to avoid competing for actions simultaneously. If 'properties.policy.unit=TOTAL', a value >= 40 must be chosen.
	ScaleOutThreshold *float64 `json:"scaleOutThreshold,omitempty" tf:"scale_out_threshold,omitempty"`

	// Units of the applied Metric. Possible values are: PER_HOUR, PER_MINUTE, PER_SECOND, TOTAL.
	Unit *string `json:"unit,omitempty" tf:"unit,omitempty"`
}

type PolicyParameters struct {

	// The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals.
	// +kubebuilder:validation:Optional
	Metric *string `json:"metric" tf:"metric,omitempty"`

	// Specifies the time range for which the samples are to be aggregated. Must be >= 2 minutes.
	// +kubebuilder:validation:Optional
	Range *string `json:"range,omitempty" tf:"range,omitempty"`

	// Defines the action to be taken when the 'scaleInThreshold' is exceeded. Here, scaling is always about removing VMs associated with this VM Auto Scaling Group. By default, the termination policy is 'OLDEST_SERVER_FIRST' is effective.
	// +kubebuilder:validation:Optional
	ScaleInAction *ScaleInActionParameters `json:"scaleInAction" tf:"scale_in_action,omitempty"`

	// The upper threshold for the value of the 'metric'. Used with the 'greater than' (>) operator. A scale-out action is triggered when this value is exceeded, specified by the 'scale_out_action' property. The value must have a lower minimum delta to the 'scale_in_threshold', depending on the metric, to avoid competing for actions simultaneously. If 'properties.policy.unit=TOTAL', a value >= 40 must be chosen.
	// +kubebuilder:validation:Optional
	ScaleInThreshold *float64 `json:"scaleInThreshold" tf:"scale_in_threshold,omitempty"`

	// Defines the action to be performed when the 'scaleOutThreshold' is exceeded. Here, scaling is always about adding new VMs to this VM Auto Scaling Group.
	// +kubebuilder:validation:Optional
	ScaleOutAction *ScaleOutActionParameters `json:"scaleOutAction" tf:"scale_out_action,omitempty"`

	// The upper threshold for the value of the 'metric'. Used with the 'greater than' (>) operator. A scale-out action is triggered when this value is exceeded, specified by the 'scaleOutAction' property. The value must have a lower minimum delta to the 'scaleInThreshold', depending on the metric, to avoid competing for actions simultaneously. If 'properties.policy.unit=TOTAL', a value >= 40 must be chosen.
	// +kubebuilder:validation:Optional
	ScaleOutThreshold *float64 `json:"scaleOutThreshold" tf:"scale_out_threshold,omitempty"`

	// Units of the applied Metric. Possible values are: PER_HOUR, PER_MINUTE, PER_SECOND, TOTAL.
	// +kubebuilder:validation:Optional
	Unit *string `json:"unit" tf:"unit,omitempty"`
}

type ReplicaConfigurationInitParameters struct {

	// The zone where the VMs are created using this configuration.
	AvailabilityZone *string `json:"availabilityZone,omitempty" tf:"availability_zone,omitempty"`

	// The zone where the VMs are created using this configuration.
	CPUFamily *string `json:"cpuFamily,omitempty" tf:"cpu_family,omitempty"`

	// The total number of cores for the VMs.
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// Set of NICs associated with this Replica.
	Nic []NicInitParameters `json:"nic,omitempty" tf:"nic,omitempty"`

	// The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
	RAM *float64 `json:"ram,omitempty" tf:"ram,omitempty"`

	// List of volumes associated with this Replica.
	Volume []VolumeInitParameters `json:"volume,omitempty" tf:"volume,omitempty"`
}

type ReplicaConfigurationObservation struct {

	// The zone where the VMs are created using this configuration.
	AvailabilityZone *string `json:"availabilityZone,omitempty" tf:"availability_zone,omitempty"`

	// The zone where the VMs are created using this configuration.
	CPUFamily *string `json:"cpuFamily,omitempty" tf:"cpu_family,omitempty"`

	// The total number of cores for the VMs.
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// Set of NICs associated with this Replica.
	Nic []NicObservation `json:"nic,omitempty" tf:"nic,omitempty"`

	// The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
	RAM *float64 `json:"ram,omitempty" tf:"ram,omitempty"`

	// List of volumes associated with this Replica.
	Volume []VolumeObservation `json:"volume,omitempty" tf:"volume,omitempty"`
}

type ReplicaConfigurationParameters struct {

	// The zone where the VMs are created using this configuration.
	// +kubebuilder:validation:Optional
	AvailabilityZone *string `json:"availabilityZone" tf:"availability_zone,omitempty"`

	// The zone where the VMs are created using this configuration.
	// +kubebuilder:validation:Optional
	CPUFamily *string `json:"cpuFamily,omitempty" tf:"cpu_family,omitempty"`

	// The total number of cores for the VMs.
	// +kubebuilder:validation:Optional
	Cores *float64 `json:"cores" tf:"cores,omitempty"`

	// Set of NICs associated with this Replica.
	// +kubebuilder:validation:Optional
	Nic []NicParameters `json:"nic,omitempty" tf:"nic,omitempty"`

	// The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
	// +kubebuilder:validation:Optional
	RAM *float64 `json:"ram" tf:"ram,omitempty"`

	// List of volumes associated with this Replica.
	// +kubebuilder:validation:Optional
	Volume []VolumeParameters `json:"volume,omitempty" tf:"volume,omitempty"`
}

type ScaleInActionInitParameters struct {

	// When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are removed. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always removed. Note that for 'SCALE_IN' operations, volumes are not deleted after the server is deleted.
	Amount *float64 `json:"amount,omitempty" tf:"amount,omitempty"`

	// The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
	AmountType *string `json:"amountType,omitempty" tf:"amount_type,omitempty"`

	// The minimum time that elapses after the start of this scaling action until the following scaling action is started. While a scaling action is in progress, no second action is initiated for the same VM Auto Scaling Group. Instead, the metric is re-evaluated after the current scaling action completes (either successfully or with errors). This is currently validated with a minimum value of 2 minutes and a maximum of 24 hours. The default value is 5 minutes if not specified.
	CooldownPeriod *string `json:"cooldownPeriod,omitempty" tf:"cooldown_period,omitempty"`

	// If set to 'true', when deleting an replica during scale in, any attached volume will also be deleted. When set to 'false', all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
	DeleteVolumes *bool `json:"deleteVolumes,omitempty" tf:"delete_volumes,omitempty"`

	// The type of termination policy for the VM Auto Scaling Group to follow a specific pattern for scaling-in replicas. The default termination policy is 'OLDEST_SERVER_FIRST'.
	TerminationPolicyType *string `json:"terminationPolicyType,omitempty" tf:"termination_policy_type,omitempty"`
}

type ScaleInActionObservation struct {

	// When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are removed. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always removed. Note that for 'SCALE_IN' operations, volumes are not deleted after the server is deleted.
	Amount *float64 `json:"amount,omitempty" tf:"amount,omitempty"`

	// The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
	AmountType *string `json:"amountType,omitempty" tf:"amount_type,omitempty"`

	// The minimum time that elapses after the start of this scaling action until the following scaling action is started. While a scaling action is in progress, no second action is initiated for the same VM Auto Scaling Group. Instead, the metric is re-evaluated after the current scaling action completes (either successfully or with errors). This is currently validated with a minimum value of 2 minutes and a maximum of 24 hours. The default value is 5 minutes if not specified.
	CooldownPeriod *string `json:"cooldownPeriod,omitempty" tf:"cooldown_period,omitempty"`

	// If set to 'true', when deleting an replica during scale in, any attached volume will also be deleted. When set to 'false', all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
	DeleteVolumes *bool `json:"deleteVolumes,omitempty" tf:"delete_volumes,omitempty"`

	// The type of termination policy for the VM Auto Scaling Group to follow a specific pattern for scaling-in replicas. The default termination policy is 'OLDEST_SERVER_FIRST'.
	TerminationPolicyType *string `json:"terminationPolicyType,omitempty" tf:"termination_policy_type,omitempty"`
}

type ScaleInActionParameters struct {

	// When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are removed. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always removed. Note that for 'SCALE_IN' operations, volumes are not deleted after the server is deleted.
	// +kubebuilder:validation:Optional
	Amount *float64 `json:"amount" tf:"amount,omitempty"`

	// The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
	// +kubebuilder:validation:Optional
	AmountType *string `json:"amountType" tf:"amount_type,omitempty"`

	// The minimum time that elapses after the start of this scaling action until the following scaling action is started. While a scaling action is in progress, no second action is initiated for the same VM Auto Scaling Group. Instead, the metric is re-evaluated after the current scaling action completes (either successfully or with errors). This is currently validated with a minimum value of 2 minutes and a maximum of 24 hours. The default value is 5 minutes if not specified.
	// +kubebuilder:validation:Optional
	CooldownPeriod *string `json:"cooldownPeriod,omitempty" tf:"cooldown_period,omitempty"`

	// If set to 'true', when deleting an replica during scale in, any attached volume will also be deleted. When set to 'false', all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
	// +kubebuilder:validation:Optional
	DeleteVolumes *bool `json:"deleteVolumes" tf:"delete_volumes,omitempty"`

	// The type of termination policy for the VM Auto Scaling Group to follow a specific pattern for scaling-in replicas. The default termination policy is 'OLDEST_SERVER_FIRST'.
	// +kubebuilder:validation:Optional
	TerminationPolicyType *string `json:"terminationPolicyType,omitempty" tf:"termination_policy_type,omitempty"`
}

type ScaleOutActionInitParameters struct {

	// When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are added. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added or removed.
	Amount *float64 `json:"amount,omitempty" tf:"amount,omitempty"`

	// The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
	AmountType *string `json:"amountType,omitempty" tf:"amount_type,omitempty"`

	// The minimum time that elapses after the start of this scaling action until the following scaling action is started. While a scaling action is in progress, no second action is initiated for the same VM Auto Scaling Group. Instead, the metric is re-evaluated after the current scaling action completes (either successfully or with errors). This is currently validated with a minimum value of 2 minutes and a maximum of 24 hours. The default value is 5 minutes if not specified.
	CooldownPeriod *string `json:"cooldownPeriod,omitempty" tf:"cooldown_period,omitempty"`
}

type ScaleOutActionObservation struct {

	// When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are added. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added or removed.
	Amount *float64 `json:"amount,omitempty" tf:"amount,omitempty"`

	// The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
	AmountType *string `json:"amountType,omitempty" tf:"amount_type,omitempty"`

	// The minimum time that elapses after the start of this scaling action until the following scaling action is started. While a scaling action is in progress, no second action is initiated for the same VM Auto Scaling Group. Instead, the metric is re-evaluated after the current scaling action completes (either successfully or with errors). This is currently validated with a minimum value of 2 minutes and a maximum of 24 hours. The default value is 5 minutes if not specified.
	CooldownPeriod *string `json:"cooldownPeriod,omitempty" tf:"cooldown_period,omitempty"`
}

type ScaleOutActionParameters struct {

	// When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are added. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added or removed.
	// +kubebuilder:validation:Optional
	Amount *float64 `json:"amount" tf:"amount,omitempty"`

	// The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
	// +kubebuilder:validation:Optional
	AmountType *string `json:"amountType" tf:"amount_type,omitempty"`

	// The minimum time that elapses after the start of this scaling action until the following scaling action is started. While a scaling action is in progress, no second action is initiated for the same VM Auto Scaling Group. Instead, the metric is re-evaluated after the current scaling action completes (either successfully or with errors). This is currently validated with a minimum value of 2 minutes and a maximum of 24 hours. The default value is 5 minutes if not specified.
	// +kubebuilder:validation:Optional
	CooldownPeriod *string `json:"cooldownPeriod,omitempty" tf:"cooldown_period,omitempty"`
}

type TargetGroupInitParameters struct {

	// The port for the target group.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// The ID of the target group.
	// +crossplane:generate:reference:type=github.com/ionos-cloud/provider-upjet-ionoscloud/apis/cluster/alb/v1alpha1.TargetGroup
	TargetGroupID *string `json:"targetGroupId,omitempty" tf:"target_group_id,omitempty"`

	// Reference to a TargetGroup in alb to populate targetGroupId.
	// +kubebuilder:validation:Optional
	TargetGroupIDRef *v1.Reference `json:"targetGroupIdRef,omitempty" tf:"-"`

	// Selector for a TargetGroup in alb to populate targetGroupId.
	// +kubebuilder:validation:Optional
	TargetGroupIDSelector *v1.Selector `json:"targetGroupIdSelector,omitempty" tf:"-"`

	// The weight for the target group.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type TargetGroupObservation struct {

	// The port for the target group.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// The ID of the target group.
	TargetGroupID *string `json:"targetGroupId,omitempty" tf:"target_group_id,omitempty"`

	// The weight for the target group.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type TargetGroupParameters struct {

	// The port for the target group.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port" tf:"port,omitempty"`

	// The ID of the target group.
	// +crossplane:generate:reference:type=github.com/ionos-cloud/provider-upjet-ionoscloud/apis/cluster/alb/v1alpha1.TargetGroup
	// +kubebuilder:validation:Optional
	TargetGroupID *string `json:"targetGroupId,omitempty" tf:"target_group_id,omitempty"`

	// Reference to a TargetGroup in alb to populate targetGroupId.
	// +kubebuilder:validation:Optional
	TargetGroupIDRef *v1.Reference `json:"targetGroupIdRef,omitempty" tf:"-"`

	// Selector for a TargetGroup in alb to populate targetGroupId.
	// +kubebuilder:validation:Optional
	TargetGroupIDSelector *v1.Selector `json:"targetGroupIdSelector,omitempty" tf:"-"`

	// The weight for the target group.
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight" tf:"weight,omitempty"`
}

type VolumeInitParameters struct {

	// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
	BackupUnitID *string `json:"backupUnitId,omitempty" tf:"backup_unit_id,omitempty"`

	// Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume.
	// Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
	// Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
	BootOrder *string `json:"bootOrder,omitempty" tf:"boot_order,omitempty"`

	// The bus type of the volume. Default setting is 'VIRTIO'. The bus type 'IDE' is also supported.
	Bus *string `json:"bus,omitempty" tf:"bus,omitempty"`

	// The image installed on the disk. Currently, only the UUID of the image is supported. Note that either 'image' or 'imageAlias' must be specified, but not both.
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// The image installed on the volume. Must be an 'imageAlias' as specified via the images API. Note that one of 'image' or 'imageAlias' must be set, but not both.
	ImageAlias *string `json:"imageAlias,omitempty" tf:"image_alias,omitempty"`

	// Image password for this replica volume.
	ImagePasswordSecretRef *v1.SecretKeySelector `json:"imagePasswordSecretRef,omitempty" tf:"-"`

	// Name for this replica volume.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	SSHKeys []*string `json:"sshKeys,omitempty" tf:"ssh_keys,omitempty"`

	// User-defined size for this replica volume in GB.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// Storage Type for this replica volume. Possible values: SSD, HDD, SSD_STANDARD or SSD_PREMIUM
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// User-data (Cloud Init) for this replica volume.
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`
}

type VolumeObservation struct {

	// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
	BackupUnitID *string `json:"backupUnitId,omitempty" tf:"backup_unit_id,omitempty"`

	// Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume.
	// Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
	// Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
	BootOrder *string `json:"bootOrder,omitempty" tf:"boot_order,omitempty"`

	// The bus type of the volume. Default setting is 'VIRTIO'. The bus type 'IDE' is also supported.
	Bus *string `json:"bus,omitempty" tf:"bus,omitempty"`

	// The image installed on the disk. Currently, only the UUID of the image is supported. Note that either 'image' or 'imageAlias' must be specified, but not both.
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// The image installed on the volume. Must be an 'imageAlias' as specified via the images API. Note that one of 'image' or 'imageAlias' must be set, but not both.
	ImageAlias *string `json:"imageAlias,omitempty" tf:"image_alias,omitempty"`

	// Name for this replica volume.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	SSHKeys []*string `json:"sshKeys,omitempty" tf:"ssh_keys,omitempty"`

	// User-defined size for this replica volume in GB.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// Storage Type for this replica volume. Possible values: SSD, HDD, SSD_STANDARD or SSD_PREMIUM
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// User-data (Cloud Init) for this replica volume.
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`
}

type VolumeParameters struct {

	// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
	// +kubebuilder:validation:Optional
	BackupUnitID *string `json:"backupUnitId,omitempty" tf:"backup_unit_id,omitempty"`

	// Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume.
	// Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
	// Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
	// +kubebuilder:validation:Optional
	BootOrder *string `json:"bootOrder" tf:"boot_order,omitempty"`

	// The bus type of the volume. Default setting is 'VIRTIO'. The bus type 'IDE' is also supported.
	// +kubebuilder:validation:Optional
	Bus *string `json:"bus,omitempty" tf:"bus,omitempty"`

	// The image installed on the disk. Currently, only the UUID of the image is supported. Note that either 'image' or 'imageAlias' must be specified, but not both.
	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// The image installed on the volume. Must be an 'imageAlias' as specified via the images API. Note that one of 'image' or 'imageAlias' must be set, but not both.
	// +kubebuilder:validation:Optional
	ImageAlias *string `json:"imageAlias,omitempty" tf:"image_alias,omitempty"`

	// Image password for this replica volume.
	// +kubebuilder:validation:Optional
	ImagePasswordSecretRef *v1.SecretKeySelector `json:"imagePasswordSecretRef,omitempty" tf:"-"`

	// Name for this replica volume.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKeys []*string `json:"sshKeys,omitempty" tf:"ssh_keys,omitempty"`

	// User-defined size for this replica volume in GB.
	// +kubebuilder:validation:Optional
	Size *float64 `json:"size" tf:"size,omitempty"`

	// Storage Type for this replica volume. Possible values: SSD, HDD, SSD_STANDARD or SSD_PREMIUM
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`

	// User-data (Cloud Init) for this replica volume.
	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`
}

// AutoscalingGroupSpec defines the desired state of AutoscalingGroup
type AutoscalingGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AutoscalingGroupParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider AutoscalingGroupInitParameters `json:"initProvider,omitempty"`
}

// AutoscalingGroupStatus defines the observed state of AutoscalingGroup.
type AutoscalingGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AutoscalingGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// AutoscalingGroup is the Schema for the AutoscalingGroups API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,ionos}
type AutoscalingGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.maxReplicaCount) || (has(self.initProvider) && has(self.initProvider.maxReplicaCount))",message="spec.forProvider.maxReplicaCount is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.minReplicaCount) || (has(self.initProvider) && has(self.initProvider.minReplicaCount))",message="spec.forProvider.minReplicaCount is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.policy) || (has(self.initProvider) && has(self.initProvider.policy))",message="spec.forProvider.policy is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.replicaConfiguration) || (has(self.initProvider) && has(self.initProvider.replicaConfiguration))",message="spec.forProvider.replicaConfiguration is a required parameter"
	Spec   AutoscalingGroupSpec   `json:"spec"`
	Status AutoscalingGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AutoscalingGroupList contains a list of AutoscalingGroups
type AutoscalingGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AutoscalingGroup `json:"items"`
}

// Repository type metadata.
var (
	AutoscalingGroup_Kind             = "AutoscalingGroup"
	AutoscalingGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: AutoscalingGroup_Kind}.String()
	AutoscalingGroup_KindAPIVersion   = AutoscalingGroup_Kind + "." + CRDGroupVersion.String()
	AutoscalingGroup_GroupVersionKind = CRDGroupVersion.WithKind(AutoscalingGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&AutoscalingGroup{}, &AutoscalingGroupList{})
}
